/**
 * PNL (Profit & Loss) Card Commands
 * Generate shareable PNL summaries for token calls
 */

import type { Context, Telegraf } from 'telegraf';
import { groupLeaderboard } from '../../services/groupLeaderboard';
import { logger } from '../../utils/logger';

/**
 * Format PNL card for a single call
 */
function formatPNLCard(call: any, anonymous: boolean = false): string {
  const username = anonymous ? 'ğŸ‘¤ Anonymous' : `ğŸ‘¤ ${call.username || `User${call.userId.slice(-4)}`}`;
  const symbol = call.symbol || call.tokenMint.slice(0, 6);
  const roi = call.currentReturn || 1.0;
  const roiPercent = ((roi - 1) * 100).toFixed(1);
  const points = call.points || 0;
  
  // Color coding for ROI
  let roiEmoji = 'ğŸ“Š';
  let roiLabel = 'Neutral';
  if (roi >= 10) { roiEmoji = 'ğŸ’'; roiLabel = 'MOON'; }
  else if (roi >= 5) { roiEmoji = 'ğŸš€'; roiLabel = 'Rocket'; }
  else if (roi >= 2) { roiEmoji = 'ğŸ“ˆ'; roiLabel = 'Profit'; }
  else if (roi < 0.8) { roiEmoji = 'ğŸ“‰'; roiLabel = 'Loss'; }
  if (call.isRug) { roiEmoji = 'ğŸš¨'; roiLabel = 'RUG'; }

  // Format prices
  const entryPrice = formatPrice(call.entryPrice);
  const currentPrice = formatPrice(call.currentPrice || call.entryPrice);
  const athPrice = call.athPrice ? formatPrice(call.athPrice) : currentPrice;

  // Calculate time held
  const now = Math.floor(Date.now() / 1000);
  const timeHeld = formatDuration(now - call.calledAt);

  let message = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `â”ƒ ${roiEmoji} <b>PNL CARD - ${roiLabel.toUpperCase()}</b>\n`;
  message += `â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

  message += `ğŸª™ <b>${symbol}</b>\n`;
  message += `${username}\n`;
  message += `â±ï¸ Held: ${timeHeld}\n\n`;

  message += `â”â” <b>Performance</b> â”â”\n`;
  message += `ğŸ“¥ Entry: ${entryPrice}\n`;
  message += `ğŸ“Š Current: ${currentPrice}\n`;
  message += `ğŸ¯ ATH: ${athPrice}\n\n`;

  // ROI display with visual bar
  const roiBar = createROIBar(roi);
  message += `ğŸ’° <b>ROI: ${roi.toFixed(2)}x (${roiPercent}%)</b>\n`;
  message += `${roiBar}\n\n`;

  // Points
  message += `ğŸ’ <b>Points: ${points >= 0 ? '+' : ''}${points}</b>\n\n`;

  // Market cap if available
  if (call.entryMcap) {
    const currentMcap = call.currentReturn ? call.entryMcap * call.currentReturn : call.entryMcap;
    message += `ğŸ“ˆ MCap: ${formatNumber(call.entryMcap)} â†’ ${formatNumber(currentMcap)}\n\n`;
  }

  // Token address
  message += `<code>${call.tokenMint.slice(0, 12)}...${call.tokenMint.slice(-8)}</code>\n\n`;

  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `ğŸ“… ${new Date(call.calledAt * 1000).toLocaleString()}\n`;
  message += `ğŸ¤– <i>Generated by Solana Memecoin Bot</i>`;

  return message;
}

/**
 * Create visual ROI bar
 */
function createROIBar(roi: number): string {
  const maxBars = 20;
  let bars = 0;
  
  if (roi >= 100) bars = maxBars;
  else if (roi >= 50) bars = 18;
  else if (roi >= 10) bars = 15;
  else if (roi >= 5) bars = 12;
  else if (roi >= 2) bars = 8;
  else if (roi >= 1) bars = Math.floor((roi - 1) * 8);
  else bars = 0;

  const filled = 'â–ˆ'.repeat(Math.min(bars, maxBars));
  const empty = 'â–‘'.repeat(Math.max(0, maxBars - bars));
  
  return filled + empty;
}

/**
 * Format group-wide PNL summary
 */
function formatGroupPNL(calls: any[], timeframe: string): string {
  if (calls.length === 0) {
    return `ğŸ“Š <b>Group PNL (${timeframe})</b>\n\nNo calls in this timeframe!`;
  }

  // Calculate aggregate stats
  const totalCalls = calls.length;
  const winners = calls.filter(c => c.currentReturn >= 1.0).length;
  const losers = calls.filter(c => c.currentReturn < 1.0 && !c.isRug).length;
  const rugs = calls.filter(c => c.isRug).length;
  const winRate = ((winners / totalCalls) * 100).toFixed(1);

  const totalPoints = calls.reduce((sum, c) => sum + (c.points || 0), 0);
  const avgROI = (calls.reduce((sum, c) => sum + (c.currentReturn || 1.0), 0) / totalCalls).toFixed(2);

  // Best and worst calls
  const bestCall = calls.reduce((best, c) => 
    (c.currentReturn || 0) > (best.currentReturn || 0) ? c : best
  );
  const worstCall = calls.reduce((worst, c) => 
    !c.isRug && (c.currentReturn || 1) < (worst.currentReturn || 1) ? c : worst
  );

  let message = `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `â”ƒ ğŸ“Š <b>GROUP PNL - ${timeframe.toUpperCase()}</b>\n`;
  message += `â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n`;

  message += `â”â” <b>Overview</b> â”â”\n`;
  message += `ğŸ“Š Total Calls: ${totalCalls}\n`;
  message += `âœ… Winners: ${winners} (${winRate}%)\n`;
  message += `âŒ Losers: ${losers}\n`;
  if (rugs > 0) message += `ğŸš¨ Rugs: ${rugs}\n`;
  message += `ğŸ’ Total Points: ${totalPoints}\n`;
  message += `ğŸ“ˆ Avg ROI: ${avgROI}x\n\n`;

  message += `â”â” <b>Best Call</b> â”â”\n`;
  message += `ğŸ¥‡ ${bestCall.symbol || bestCall.tokenMint.slice(0, 6)}\n`;
  message += `ğŸ‘¤ ${bestCall.username || 'Anonymous'}\n`;
  message += `ğŸ’° ${bestCall.currentReturn.toFixed(2)}x (+${((bestCall.currentReturn - 1) * 100).toFixed(0)}%)\n\n`;

  if (!worstCall.isRug && worstCall.currentReturn < 1.0) {
    message += `â”â” <b>Worst Call</b> â”â”\n`;
    message += `ğŸ“‰ ${worstCall.symbol || worstCall.tokenMint.slice(0, 6)}\n`;
    message += `ğŸ‘¤ ${worstCall.username || 'Anonymous'}\n`;
    message += `ğŸ’¸ ${worstCall.currentReturn.toFixed(2)}x (${((worstCall.currentReturn - 1) * 100).toFixed(0)}%)\n\n`;
  }

  // Performance breakdown
  const moons = calls.filter(c => c.currentReturn >= 10).length;
  const rockets = calls.filter(c => c.currentReturn >= 5 && c.currentReturn < 10).length;
  const profits = calls.filter(c => c.currentReturn >= 2 && c.currentReturn < 5).length;

  if (moons + rockets + profits > 0) {
    message += `â”â” <b>Breakdown</b> â”â”\n`;
    if (moons > 0) message += `ğŸ’ 10x+: ${moons}\n`;
    if (rockets > 0) message += `ğŸš€ 5-10x: ${rockets}\n`;
    if (profits > 0) message += `ğŸ“ˆ 2-5x: ${profits}\n`;
    message += `\n`;
  }

  message += `â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n`;
  message += `ğŸ¤– <i>Group performance summary</i>`;

  return message;
}

/**
 * Format price with appropriate decimals
 */
function formatPrice(price: number): string {
  if (price >= 1) return `$${price.toFixed(2)}`;
  if (price >= 0.01) return `$${price.toFixed(4)}`;
  if (price >= 0.0001) return `$${price.toFixed(6)}`;
  return `$${price.toExponential(2)}`;
}

/**
 * Format number with K/M/B suffixes
 */
function formatNumber(num: number): string {
  if (num >= 1_000_000_000) return `$${(num / 1_000_000_000).toFixed(2)}B`;
  if (num >= 1_000_000) return `$${(num / 1_000_000).toFixed(2)}M`;
  if (num >= 1_000) return `$${(num / 1_000).toFixed(1)}K`;
  return `$${num.toFixed(2)}`;
}

/**
 * Format duration in human-readable form
 */
function formatDuration(seconds: number): string {
  if (seconds < 60) return `${seconds}s`;
  if (seconds < 3600) return `${Math.floor(seconds / 60)}m`;
  if (seconds < 86400) return `${Math.floor(seconds / 3600)}h`;
  if (seconds < 604800) return `${Math.floor(seconds / 86400)}d`;
  return `${Math.floor(seconds / 604800)}w`;
}

/**
 * Register PNL commands
 */
export function registerPNLCommands(bot: Telegraf): void {
  /**
   * /pnl command - Generate PNL card for a specific call
   * Usage: /pnl <call_id> [anon]
   */
  bot.command('pnl', async (ctx: Context) => {
    try {
      // Only works in groups
      if (ctx.chat?.type !== 'group' && ctx.chat?.type !== 'supergroup') {
        await ctx.reply('âŒ This command only works in group chats!');
        return;
      }

      const msgText = (ctx.message && 'text' in ctx.message) ? (ctx.message as any).text : '';
      const args = msgText.split(' ').slice(1);

      if (args.length < 1) {
        await ctx.reply(
          `ğŸ“Š <b>Generate PNL Card</b>\n\n` +
          `Usage: <code>/pnl &lt;call_id&gt; [anon]</code>\n\n` +
          `Examples:\n` +
          `/pnl 123 - Show PNL for call #123\n` +
          `/pnl 123 anon - Anonymous PNL card\n\n` +
          `ğŸ’¡ Find call IDs with /calls`,
          { parse_mode: 'HTML' }
        );
        return;
      }

      const callId = parseInt(args[0]);
      const anonymous = args.includes('anon') || args.includes('anonymous');

      if (isNaN(callId)) {
        await ctx.reply('âŒ Invalid call ID!');
        return;
      }

      const groupId = ctx.chat.id.toString();

      // Get the call from database
      const call = await groupLeaderboard.getCall(callId, groupId);

      if (!call) {
        await ctx.reply('âŒ Call not found in this group!');
        return;
      }

      const message = formatPNLCard(call, anonymous);
      await ctx.reply(message, { parse_mode: 'HTML' });

      logger.info('PNLCmd', `PNL card generated for call ${callId} in group ${groupId}`);
    } catch (error) {
      logger.error('PNLCmd', 'Failed to generate PNL card', error as Error);
      await ctx.reply('âŒ Failed to generate PNL card. Please try again.');
    }
  });

  /**
   * /gpnl command - Group-wide PNL summary
   * Usage: /gpnl [timeframe]
   */
  bot.command('gpnl', async (ctx: Context) => {
    try {
      // Only works in groups
      if (ctx.chat?.type !== 'group' && ctx.chat?.type !== 'supergroup') {
        await ctx.reply('âŒ This command only works in group chats!');
        return;
      }

      const msgText = (ctx.message && 'text' in ctx.message) ? (ctx.message as any).text : '';
      const args = msgText.split(' ').slice(1);
      const timeframe = args[0] || '7d';

      if (!['1d', '7d', '30d', 'all'].includes(timeframe)) {
        await ctx.reply('âŒ Invalid timeframe! Use: 1d, 7d, 30d, or all');
        return;
      }

      const groupId = ctx.chat.id.toString();

      // Get calls for timeframe
      const calls = await groupLeaderboard.getCallsForTimeframe(groupId, timeframe);

      const message = formatGroupPNL(calls, timeframe);
      await ctx.reply(message, { parse_mode: 'HTML' });

      logger.info('PNLCmd', `Group PNL generated for ${groupId} (${timeframe})`);
    } catch (error) {
      logger.error('PNLCmd', 'Failed to generate group PNL', error as Error);
      await ctx.reply('âŒ Failed to generate group PNL. Please try again.');
    }
  });

  logger.info('Commands', 'PNL commands registered');
}
